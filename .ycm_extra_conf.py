import os
import ycm_core

SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c']
HEADER_EXTENSIONS = ['.h', '.hxx', '.hpp', '.hh']

# This youcompleteme config file should lie in the project root.
project_root = os.path.dirname(os.path.abspath(__file__))

# Flags used if no compilation database is found.
default_flags = [
    '-Wall',
    '-Wextra',
    '-std=c++11',
    '-I' + os.path.join(project_root, 'src'),
    '-I' + os.path.join(project_root, 'src', '3rd-party'),
]

# Compiling from clang the binary uses the correct default header search paths
# but compiling from libclang.so does not. Therefore, we add the right paths
# manually.
extra_flags = [
    '-I/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8',
    '-I/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/backward',
    '-I/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/x86_64-linux-gnu/c++/4.8',
    '-I/usr/local/include',
    '-I/usr/bin/../lib/clang/3.4/include',
    '-I/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/include',
    '-I/usr/include/x86_64-linux-gnu',
    '-I/usr/include'
]

# CMake generates a json database inside the build directory.
compilation_database_folder = os.path.join(project_root, 'build')

if os.path.exists(compilation_database_folder):
    database = ycm_core.CompilationDatabase(compilation_database_folder)
else:
    database = None

def GetCompilationInfoForFile(filename):
    # The compilation_commands.json file generated by CMake does not have entries
    # for header files. So we do our best by asking the db for flags for a
    # corresponding source file, if any. If one exists, the flags for that file
    # should be good enough.
    basename, extension = os.path.splitext(filename)
    if extension in HEADER_EXTENSIONS:
        for extension in SOURCE_EXTENSIONS:
            replacement_file = basename + extension
            if os.path.exists(replacement_file):
                compilation_info = database.GetCompilationInfoForFile(replacement_file)
                if compilation_info.compiler_flags_:
                    return compilation_info
        return None
    return database.GetCompilationInfoForFile(filename)

def FlagsForFile(filename, **kwargs):
    flags = default_flags

    if database:
        compilation_info = GetCompilationInfoForFile(filename)
        if compilation_info:
            flags = list(compilation_info.compiler_flags_)

    return {
        'flags': flags + extra_flags,
        'do_cache': True
    }
